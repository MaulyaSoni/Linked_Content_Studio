"""
Export Handler - Multiple Output Formats
Enables users to export posts in various formats for different platforms.
"""

from typing import Dict, List, Tuple
from datetime import datetime
from pathlib import Path
import json
import base64


class ExportHandler:
    """
    Export LinkedIn post in multiple formats:
    - Copy to clipboard ready
    - Markdown (.md)
    - Notion-ready format
    - Scheduling format (buffer/hootsuite)
    - PDF (if needed)
    """
    
    @staticmethod
    def export_for_linkedin(post_data: Dict) -> str:
        """
        Export ready-to-copy LinkedIn post.
        
        Format: Post + Hashtags ready to paste
        """
        post = post_data.get("post", "")
        hashtags = post_data.get("hashtags", "")
        
        export = f"{post}\n\n{hashtags}"
        return export
    
    @staticmethod
    def export_for_markdown(post_data: Dict, title: str = "LinkedIn Post") -> str:
        """
        Export as Markdown file format.
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        markdown = f"""# {title}

**Generated:** {timestamp}

## Post Content

{post_data.get("post", "")}

## Hashtags

```
{post_data.get("hashtags", "")}
```

### Metadata

- **Style:** {post_data.get("style", "Unknown")}
- **Tone:** {post_data.get("tone", "Unknown")}
- **Word Count:** {post_data.get("stats", {}).get("word_count", 0)}
- **Character Count:** {post_data.get("stats", {}).get("char_count", 0)}

### Quality Score

{post_data.get("quality_score", "No score")}

---

*Generated by LinkedIn Content Studio*
"""
        return markdown
    
    @staticmethod
    def export_for_notion(post_data: Dict) -> Dict:
        """
        Export in Notion-ready JSON format.
        Can be imported into Notion database.
        """
        return {
            "Title": post_data.get("post", "").split("\n")[0][:50],
            "Content": post_data.get("post", ""),
            "Hashtags": post_data.get("hashtags", ""),
            "Caption": post_data.get("caption", ""),
            "Style": post_data.get("style", ""),
            "Tone": post_data.get("tone", ""),
            "Status": "Draft",
            "Word Count": post_data.get("stats", {}).get("word_count", 0),
            "Character Count": post_data.get("stats", {}).get("char_count", 0),
            "Quality Score": str(post_data.get("quality_score", "N/A")),
            "Generated Date": datetime.now().isoformat(),
            "Ready to Post": True
        }
    
    @staticmethod
    def export_for_scheduling(post_data: Dict, platform: str = "buffer") -> Dict:
        """
        Export in scheduling platform format.
        
        Platforms: buffer, hootsuite, loom, later
        """
        base_format = {
            "text": post_data.get("post", ""),
            "tags": post_data.get("hashtags", "").split(),
            "scheduled_at": None,  # User to set
            "media": [],
            "platform": "linkedin"
        }
        
        if platform == "buffer":
            return {
                "profile_ids": [],  # User must select
                "text": base_format["text"],
                "media": {
                    "link": {
                        "url": "",  # User can add
                        "title": post_data.get("post", "").split("\n")[0][:80],
                        "description": post_data.get("caption", "")
                    }
                },
                "tags": base_format["tags"],
                "top_link": None,
                "shorten_links": True,
                "add_image": False
            }
        
        elif platform == "hootsuite":
            return {
                "message": base_format["text"],
                "social_profile_ids": [],
                "scheduled_send_time": None,
                "metadata": {
                    "style": post_data.get("style"),
                    "tone": post_data.get("tone"),
                    "quality_score": post_data.get("quality_score")
                }
            }
        
        else:  # Generic format
            return base_format
    
    @staticmethod
    def export_csv_batch(posts_list: List[Dict]) -> str:
        """
        Export multiple posts as CSV for batch scheduling.
        """
        csv_header = "Title,Content,Hashtags,Caption,Style,Tone,Word Count,Date Generated\n"
        
        csv_rows = []
        for post in posts_list:
            # Escape quotes and newlines
            post_text = post.get("post", "").replace('"', '""').replace("\n", " ")
            hashtags = post.get("hashtags", "").replace("\n", " ")
            caption = post.get("caption", "").replace('"', '""').replace("\n", " ")
            
            row = (
                f'"{post_text[:50]}","'
                f'{post_text}","'
                f'{hashtags}","'
                f'{caption}","'
                f'{post.get("style", "")}","'
                f'{post.get("tone", "")}","'
                f'{post.get("stats", {}).get("word_count", 0)}","'
                f'{datetime.now().strftime("%Y-%m-%d")}"'
            )
            csv_rows.append(row)
        
        return csv_header + "\n".join(csv_rows)
    
    @staticmethod
    def generate_download_link(content: str, filename: str, format_type: str) -> Tuple[str, str]:
        """
        Generate downloadable content and filename.
        
        Returns: (content, mimetype)
        """
        if format_type == "markdown":
            return content, "text/markdown"
        elif format_type == "json":
            return content, "application/json"
        elif format_type == "csv":
            return content, "text/csv"
        else:
            return content, "text/plain"


class PostDiffViewer:
    """
    Show improvements between drafts.
    Useful for iterative refinement.
    """
    
    @staticmethod
    def compare_posts(original: str, refined: str) -> Dict:
        """
        Compare two post versions.
        
        Returns: Diff analysis
        """
        original_lines = original.split("\n")
        refined_lines = refined.split("\n")
        
        changes = {
            "lines_added": len(refined_lines) - len(original_lines),
            "lines_removed": len(original_lines) - len(refined_lines),
            "original_length": len(original),
            "refined_length": len(refined),
            "length_change_percent": (
                ((len(refined) - len(original)) / len(original) * 100)
                if original else 0
            ),
            "diff_summary": PostDiffViewer._generate_diff_summary(original, refined)
        }
        
        return changes
    
    @staticmethod
    def _generate_diff_summary(original: str, refined: str) -> str:
        """Generate human-readable diff summary."""
        summary = []
        
        if len(refined) > len(original):
            summary.append(f"âœ‚ï¸ Added {len(refined) - len(original)} characters")
        elif len(refined) < len(original):
            summary.append(f"âœ‚ï¸ Removed {len(original) - len(refined)} characters")
        else:
            summary.append("âœ‚ï¸ Same length, reorganized content")
        
        # Check for hook changes
        original_first_line = original.split("\n")[0]
        refined_first_line = refined.split("\n")[0]
        if original_first_line != refined_first_line:
            summary.append("ğŸ£ Hook updated")
        
        # Check for emoji changes
        original_emojis = len([c for c in original if ord(c) > 127])
        refined_emojis = len([c for c in refined if ord(c) > 127])
        if refined_emojis > original_emojis:
            summary.append(f"ğŸ˜Š Added {refined_emojis - original_emojis} emojis")
        
        return " | ".join(summary) if summary else "Refined version ready"


class HookSelector:
    """
    Help users choose engagement hooks.
    Different hooks for different goals.
    """
    
    HOOKS = {
        "curiosity": [
            "I just discovered something that changes how we think about {topic}...",
            "For 5 years I got this wrong about {topic}",
            "Nobody talks about {topic}, but they should because...",
            "This {topic} lesson took me 2 years to learn"
        ],
        "bold_claim": [
            "Unpopular opinion: {topic} is the future",
            "The {topic} industry is about to shift",
            "{topic} will be worth billions in 3 years",
            "Everyone's doing {topic} wrong"
        ],
        "story": [
            "My first {topic} project failed in 48 hours. Here's what I learned...",
            "This is the story of how I built {topic}",
            "The day I realized {topic} could change everything",
            "How we went from 0 to 1 with {topic}"
        ],
        "contrarian": [
            "Most people miss this about {topic}",
            "You probably don't realize {topic} works like this",
            "The conventional wisdom about {topic} is wrong",
            "What nobody tells you about {topic}"
        ],
        "emotional": [
            "If you care about {topic}, read this ğŸ§µ",
            "This {topic} story moved me deeply",
            "I'm passionate about {topic} because of this",
            "Why {topic} matters more than you think"
        ]
    }
    
    @staticmethod
    def suggest_hooks(topic: str, style: str = None) -> Dict[str, List[str]]:
        """
        Suggest hook options for a given topic.
        
        Returns: {hook_type: [hook_options]}
        """
        suggestions = {}
        
        for hook_type, templates in HookSelector.HOOKS.items():
            suggestions[hook_type] = [
                template.replace("{topic}", topic)
                for template in templates
            ]
        
        return suggestions
    
    @staticmethod
    def get_hook_descriptions() -> Dict[str, str]:
        """Get descriptions of each hook type."""
        return {
            "curiosity": "âœ¨ Creates intrigue - viewers want to know the answer",
            "bold_claim": "ğŸ’¥ Direct and attention-grabbing - risky but effective",
            "story": "ğŸ“– Narrative-driven - builds connection and relatability",
            "contrarian": "ğŸ”¥ Goes against conventional wisdom - sparks debate",
            "emotional": "â¤ï¸ Appeals to feelings - drives engagement and shares"
        }
